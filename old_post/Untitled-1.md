1 上下文切换
CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务，这就是上下文切换。
任务从保存到再加载的过程就是一次上下文切换。
上下文切换会影响多线程的执行速度。

2.减少上下文的切换的四种方法
无锁并发编程：使用一些办法避免使用锁
CAS算法：JavaAtomic包
使用最少线程：避免创建不必要的线程
使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

避免死锁的常见方法：
避免一个线程同时获取多个锁
避免一个线程在锁内同时占用多个资源
尝试使用定时锁
对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

3.资源限制的挑战
在资源有限的情况下，即使增加并发度也无法加快速度，反而会减慢速度。

解决资源限制的方法，使用集群并行执行程序，即增加资源。对于软件资源，可以考虑资源复用。

在资源限制的情况下并发编程，可以根据不同的资源限制调整程序的并发度。

4.volatile
volatitle表示了变量的可见性，在多个线程共享一个volatitle变量时，一个线程修改了变量，另一个线程能马上看到。

volatile两条实现原则
1）Lock前缀指令会引起处理器缓存回写到内存
2)一个处理器的缓存回写到内存会导致其他处理器的缓存无效

volatile的使用优化
追加字节性能优化：在LinkedTransferQueue类中，通过将头结点和尾节点都追加到64字节的方式来优化性能。这是因为在英特尔酷睿i7、Atom和NetBurst等处理器中的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着如果头节点和尾节点都不足64字节的话，处理器会将它们读到同一个缓存行中。那么一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，降低了效率。
这个方法在高速缓存行不是64字节的处理器上不管用。另外，如果共享变量不会被频繁的写的话也没有必要使用这种方法。
这种方法在Java7下可能不生效，因为它可能会淘汰或重新排列无用字段。

5.synchronized
synchronized又称为重量级锁。
synchronized实现同步的基础：java中的每一个对象都可以作为锁。具体表现为以下三种行驶：
对于普通同步方法，锁是当前对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchronized括号里配置的对象。
线程访问同步代码块，必须先得到锁，退出或抛出异常时，必须释放锁。

JVM中锁的实现原理是基于进入和退出Monitor对象。monitorenter插入同步代码块开始的位置，而monitorexit插入到结束处和异常处，每个monitorenter必须有monitorexit与之对应。

Java对象头，每个对象都有对象头，存储了hashCode、分代年龄、是否偏向锁、锁标志位等。

6.锁的升级与对比
锁一共有4种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以升级但不能降级。

1）偏向锁
多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。
偏向锁的意思就是：在竞争较低的情况下，某个锁被某线程获取后，在对象头中记录偏向线程ID，在线程退出和下次进入同步代码块时不释放锁，而是检查偏向锁记录的线程ID，如果ID相同，则可以直接进入。
如果检查失败，就检查偏向锁标识是否设为1，如果为0，就是用CAS竞争锁，如果为1，就尝试使用CAS将偏向锁指向当前线程。
简单的说，就是竞争出现才释放锁。


2）轻量级锁
轻量级锁加锁：在执行同步代码块前，将对象头的MarkWord复制到锁记录中，称为Displaced Mark Word。然后尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，获得锁，如果失败，尝试使用自选来获取锁，如果失败，膨胀微重量级锁。

轻量级锁解锁，使用CAS将Displaced Mark Word替换回对象头，如果失败，表示当前锁存在竞争，膨胀成重量级锁。


7.java内存模型
Java内存模型的基础
并发编程的两个关键问题：通信和同步
通信机制有两种：共享内存和消息传递
Java的并发采用的是共享内存模型，线程之间的通信总是隐式进行。

java内存模型的抽象结构
实例域、静态域、数组元素存储在堆内存中，称为共享变量。
局部变量、方法定义参数、异常处理参数不会在线程之间共享。
两个线程之间要进行通信，必须一个线程先将本地变量刷新到共享内存中，另一个线程再从共享内存中读取此变量。

从源代码到指令序列的重排序
重排列分为三种类型：
编译器优化的重排序
指令级并行的重排序
内存系统的重排序
JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供已知的内存可见性保证。

单个处理器中执行的指令序列和单个线程中执行的操作有数据依赖性，即重排序时不会改变存在数据依赖关系的两个操作的执行顺序。

as-if-serial：不管怎么重排序，（单线程）程序的执行结果不能被改变。
在程序员看来，单线程程序是按程序的顺序来执行的。无需担心重排序，也无需担心内存可见性问题。

8.顺序一致性
顺序一致性内存模型的两大特性：
一个线程中的所有操作必须按照程序的顺序来执行。
（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立即对所有线程可见。

在顺序一致性模型中，即使是未同步的程序，虽然整体执行是无序的，但所有线程都只能看到一个一致的整体执行顺序。因为在顺序一致性模型中所有线程共享一块内存。

但是在JMM中没有这个保证，因为JMM中会先把写过的数据缓存在本地内存中，在没有刷新到主存之前，其他线程是看不到的。

8.volatile内存语义
可见性：对一个volatile变量的读，总是能看到对这个volatile变量最后的写。
原子性：对任意单个volatile变量的读\写具有原子性，但类似于volatile++这种复合操作不具有原子性。
