### 1 虚拟内存和物理内存

虚拟内存的概念：

​		以32位操作系统为例，系统的寻址空间只有4G，最大物理内存也为4G。运行在操作系统上的进程，它的寻址空间也是4G，也就是说，在进程看来这一块4G的连续内存都是它的，它可以敞开了用。但是事实上进程肯定是无法使用所有的物理内存的，在多个进程的情况下，如果每个进程都能访问4G的物理内存，那进程就可以修改其他进程的数据，系统就乱套了。

​		所以操作系统引入了虚拟内存，可以看作操作系统对进程进行了“欺骗“，在进程看来它可以使用4G的内存，但实际上它可能只能使用物理内存上的一小块。具体的做法是在进程的虚拟内存和物理内存之间有一个**页表**来进行**内存映射**，页表就像一个map，它记录了进程的虚拟内存的某个地址映射到物理内存中实际的地址。

进程访问虚拟内存的流程：

1. 当进程访问某块虚拟内存的数据时，首先去访问页表。页表有一个有效位和一个地址。
2. 若页表的有效位为1，表示这块数据在物理内存中，那么根据地址中记录的物理内存页号访问数据。
3. 若页表的有效位为0，表示这块数据在磁盘中，就会发生**缺页异常**。发生缺页异常时，操作系统立即阻塞此进程，并使用**页面置换算法**将磁盘中的数据拷入物理内存中，若物理内存中有剩余空间则直接拷入，若没有，则选择一页，将该页内容放入磁盘中，将需要使用的数据拷入该页，具体选择哪一页覆盖，取决于操作系统的页面置换算法。然后，将页表有效位置为1，地址栏填入新的物理内存页号，恢复该进程。



### 2 用户态和内核态

用户态：进程执行自己的代码

内核态：进程执行内核内核代码

由用户态切换到内核态的原因：

- 进程通过系统调用主动切换。
- 发生异常，如缺页异常。
- 发生中断，如硬件设备发来的中断请求。

由用户态切换到内核态的过程：

- 首先从进程中找到其内核栈的指针。
- 然后保存用户态的现场。
- CPU切换到内核态执行。
- 执行完毕后恢复到用户态执行。



### 3 windows进程间通信方式

- 共享内存
- SendMessage
- 剪贴板
- 匿名管道
- 命名管道
- socket
- 动态链接库



### 4 什么是孤儿进程和僵尸进程，怎么解决

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

僵尸进程将会占用系统的进程号，进程号满了后对系统有危害。而孤儿进程会被init进程收养，不会产生什么危害。

解决僵尸进程最好的办法就是结束它的父进程。



### 5 进程的三种基本状态

1. Ready：进程已获得除处理器外的所需资源，只是在等待分配处理器资源，只要分配了处理器进程就可执行。
2. Running：进程占用处理器资源，处于此状态的进程的数目小于等于处理器的数目。
3. Blicking：系统由于进程等待某种条件（如[I/O操作](https://www.baidu.com/s?wd=I%2FO操作&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)或[进程同步](https://www.baidu.com/s?wd=进程同步&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，该进程也无法进行运行。

