### 1 电商秒杀项目

这个项目主要是模拟了网上商城举办的一个线上秒杀活动，那么秒杀活动就要面对一个高并发请求的问题，那么在高并发请求情境下主要的性能瓶颈来自于数据库，因此，这个项目就是主要围绕着如何减轻数据库的压力，提高秒杀接口的QPS来进行。

我们以从数据库到前端的顺序来进行介绍。

1. 首先，在数据库中，为每张表建立合适的索引，建立索引的依据就是根据SQL语句来建立索引。比如在订单表中有一个关键的查询操作是：根据用户的id和商品id来查询订单，那么就在用户id、商品id上建一个联合索引。
2. 对于秒杀这个接口来说，主要的访问数据库的操作有查询库存、查询订单，减少库存、生成订单。
   - 查询库存也就是商品的余量，对于这个操作，首先在秒杀活动一开始的时候就将商品的库存加载到redis，在进行秒杀的时候先去查询redis中的库存。然后，在controller类中再定义一个map，标记每种商品的库存是否为空了，当某次查询redis发现库存为空之后，就将这个标记置为false，那么在查询redis之前，先去查这个map，可以有效的减少对redis的访问，减少网络开销。
   - 对于第二个查询操作，查询用户是否已经秒杀过这个商品了，也使用redis来缓存。在生成每个成功的订单，将订单写入数据库之后，也写入redis。这样可以减少这个查询对redis的访问。
   - 对于较少库存操作，分为两步进行，第一步是redis预减库存，这里只减少redis中记录的库存。这样可以帮助快速过滤掉那些秒杀失败的请求。
   - 然后到这里，上面已经帮我们过滤掉大量失败的请求了，但是，成功的请求也可能很多，比如有100种商品参加秒杀，每种1000个，这样也有十万个成功的请求。所以对于成功的请求，我们也不能直接去写入数据库，而是将他们加入消息队列。然后在消息队列的接收端，来处理生成订单，写入数据库这样的操作。
3. 对于前端来说，主要可以做这样几个工作。
   - 首先，可以在点击立即秒杀按钮的时候，弹出一个验证码，只有输入验证码正确的才会请求到服务端。
   - 在请求到服务端的时候，如果秒杀失败，就立即显示失败。否则，可能加入消息队列中了，去轮询另一个接口查看是否下单成功，中途显示请稍后。
   - 最后，可以做一个接口限流的工作，也就是单个用户，一秒内只能访问秒杀接口十次，这个计数功能是使用redis实现的。

### 2 InteMECo机械电子协同

这个项目主要解决这样一个问题，就是对于电路板的设计，比如手机主板，需要经历电路设计与结构设计两个步骤，但是呢，进行这两步设计的设计师通常不会是同一个人，有可能分布在一个公司的两个部门，甚至有可能是不同公司不同国家。那么在过去，通常是电子这边先设计好电路板，生产出样品之后，再交给结构这边，机构设计师在设计结构的过程种发现电路设计某处不太合理，再发回去修改。这样产品设计的迭代周期就会非常长。那么机械电子协同，就是让双方设计师对同一块电路板的设计，即使是最微小的改动也能即使传递，结构和电子的设计同步进行。

那么体现在软件开发上，就是对设计结构的辅助软件和设计电子的辅助软件进行协同，也就是这个项目的名臣MECo，M代表mechanical，E代表Electrical电子，Co代表cooperation协作。

在这个项目种我主要是负责开发了一个工具叫做天喻Validate，也就是一个验证工具。刚才说到交换信息，它就可以对交换的信息进行查看和验证。比如电子工程师对电路板进行了若干改动，将改动的文件发过来。然后我对这个改动文件进行解析，显示有哪些改动。然后结构工程师可以用我的工具预览有哪些改动，并选择接受或者否决某些改动，然后结构工程师的验证结果也输出成文件，再发回给电子工程师，这就是一个协同过程。反过来也是类似。

在项目中碰到的小困难也比较多，比较突出的由我解决的有实现了一个windows进程间的通信，一个检测内存泄漏，为程序各部分做耗时的统计，以及解决一些图形算法上的问题等，比如二维图的分离。

### 3 Cadence集成plm

这个项目主要是我们plm系统中的一部分，plm指的是产品全生命周期管理，Cadence是一个进行电路板设计的软件，那么电路板的设计当然也是产品生命周期的一部分。所以要将Cadence与plm进行一个集成，将Cadence种的设计图纸等导出到plm进行管理。

我做的工作主要有：为Cadence软件自定义一个菜单，然后使用TCL脚本语言为菜单编写响应函数，这写响应函数就负责从Cadence软件中导出一些需要管理的信息，生成设计图、pdf、bom表、xml文件等。然后实现一个托盘程序，类似于腾讯QQ这样的，可以最小化右下角的。用于登录plm系统，向plm导入导出文件。

比较难的一个点就是我在这个项目中遇到的一个问题，Cadence的菜单响应函数是用TCL编写的，而我们的托盘程序是一个C++程序，这两者通信有一些困难。我只找到了一种方法，也就是TCL可以使用exec命令来启动另一个程序，然后在命令行参数中将要传递的数据传输过去。但是这又产生一个新的问题，那就是TCL是一个脚本语言，它要按顺序执行，它用exec启动另一个程序后要等待返回值才会继续。这样就使Cadence卡在那里不动了，相当于两个程序同步了，而我们要的是异步执行。于是我就想了一个办法，我又写了另一个程序，这个程序相当于一个转发者。TCL启动这个程序之后，将数据传给它，它只做一件事，在内存中开辟一块缓存，然后将数据放在缓存中，马上返回。这时候我们的托盘程序会轮询事先约定好的缓存名称，一旦发现有新的数据它就读取并处理。这样就实现了一个异步。

但是这样做不太安全，因为这块缓存是任何进程都可以访问的，其他进程只要知道缓存的名称，也可以对这块缓存进行修改，所以非常不安全。