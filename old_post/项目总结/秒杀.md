### 1 分布式Session

将session存储在redis中实现分布式session。首次登录为其生成token和session，将token，session存放在redis中，再将token放在cookie中返回给客户端。当客户端访问其它页面时，会携带cookie，这时就通过cookie中的token来拿到session。当cookie失效时，就无法拿到session，那么就要重新登录。

### 2 JSR303参数校验

主要是对前端的请求参数进行校验。将请求参数绑定到一个类上，在这个类成员上使用注解来进行校验，比如@NotNULL @NULL等。使用了一个自定义注解，来验证手机号码的格式正确定。@IsMobile注解，主要是模仿其它注解的实现方法，首先定义IsMobile注解，然后实现一个继承ConstraintValidator接口的类，主要是实现其中的一个isValid方法。

### 3 全局异常处理器

@ControllerAdvice@ResponseBody注解，在里面根据Exception的类型进行不同的处理。

### 4 秒杀功能开发及管理后台

1. 商品列表页

   登录成功后，跳转到to_list控制器，查询到商品信息后显示在列表页面上。

   技术点1：controller方法的参数可以自动绑定，使用HandlerMethodArgumentResolver相关内容实现。

   技术点2：普通商品和秒杀商品在数据库中用两张表存储。在服务端中重新定义一个GoodsVo来集合普通商品和秒杀商品的信息。

2. 商品详情页

   在商品列表页点击详情跳转到商品详情页，在跳转时卸载商品id参数。根据参数从goods和miaosha_goods两张表中联结查询出商品详细信息。
   
   技术点1：后台给前端返回商品秒杀状态和距离秒杀开始时间两个参数，由前端处理显示不同的页面和秒杀倒计时。这样可以减轻服务器的压力。
   
3. 秒杀功能实现

   点击秒杀，将减库存，下订单，写入订单设为一个事务。将订单详情和商品详情一同返回，显示在订单详情页。

### 5 压测

主要是用jmeter进行压测，没什么好说的。需要注意的是本机的数据库、服务端程序、jmeter运行在同一台机器上，导致服务器的性能瓶颈反而不那么明显，反而是服务端程序和jmeter占用的硬件资源更高。

### 6 优化

1. 商品列表页页面缓存实现

   技术点1：页面缓存。在客户端请求商品列表页面时，需要查询一次mysql数据库，查询到若干条商品记录，再经过渲染返回html。页面缓存就是将再首次查询后，将渲染的页面存在redis缓存中，当再次访问商品列表页面时，首先尝试从redis中获取商品列表，减少了对mysql数据库的访问。

   技术点2：页面缓存的有效期不能过长，一般应该在几分钟之内，因为商品列表数据是会变化的，如果长期使用缓存中的页面会使用户无法访问到真实的商品列表。

2. 对象缓存

   技术点1：将热点对象缓存在redis中，减少对mysql的访问。但是要注意，当对象发生更新时，应对所有该对象的缓存都进行更新。

   技术点2：应严格使用service之间互相调用，不应该调用其它类的dao，因为service方法中很可能使用了缓存，调用dao会跳过缓存。



### 7 秒杀接口优化

1. 总体思路
   - redis预加载库存
   - 请求到来时，先减少redis库存，若redis库存不足直接返回失败
   - 否则加入消息队列，返回等待中
   - 消息出队，下订单，减少数据库库存
   - 页面轮询秒杀状态
2. 使用内存标记减少redis访问
3. 使用rabbitmq异步下单

### 8 RabbitMQ

使用config创建一个queue，用sender发送消息，receiver接收消息。

### 9 RabbitMQ的四种交换机模式

1. direct模式
2. topic模式：使用一个TopicExchange，先将消息放到Exchange中，



### 10 安全优化

1. 接口地址隐藏

   点击立即秒杀的时候不直接请求到秒杀接口，而是先向另一个接口path请求秒杀地址，path会生成一个随机值返回并将此随机值放在redis中。客户端接收到这个随即之后，将这个随机值和秒杀接口的url组合起来发送到秒杀接口，秒杀接口对此参数进行验证。

###  