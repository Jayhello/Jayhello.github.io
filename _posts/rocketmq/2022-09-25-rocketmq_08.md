---
layout: post
title: "RocketMQ原理-Broker基本介绍"
date:   2022-09-25
tags: [RocketMQ]
comments: true
author: xy
# toc: true  # 这里加目录导致看到地方太小了
---

主要内容如下:

1. `RocketMQ` `Broker`的启动流程以及重要功能介绍

2. `RocketMQ` 如何实现顺序消息的生产

3. 生产者顺序消息需要注意的事项

### 1. `Broker`的启动流程

`Broker`的启动类和控制器分别为 `BrokerStartup`、`BrokerController`这个和`NameServer`类似。

启动类就是读取配置(server, 存储, client等), 然后构造controller启动:
```java
public class BrokerStartup{
public static void main(String[] args) {
    BrokerConfig brokerConfig = new BrokerConfig();
    NettyServerConfig nettyServerConfig = new NettyServerConfig();
    NettyClientConfig nettyClientConfig = new NettyClientConfig();
    MessageStoreConfig messageStoreConfig = new MessageStoreConfig();

    BrokerController controller = new BrokerController(config..);

    controller.start();}
```

BrokerController 作为中介者依赖了大量的组件，这里就不贴代码了，对其简单归类可分为如下几大类:

1. 配置对象：Broker、Netty、消息存储等配置(一般以json文件的方式存储在本地)

2. 网络组件：基于Netty的服务器和客户端、API调用等

3. 生产者组件：生产者管理组件

4. 消费者组件：消费者管理、拉取消息、消费偏移量管理等组件

5. 消息存储：消息本地存储组件


核心成员如下:

```java
public class BrokerController {
    private final BrokerConfig brokerConfig;
    private final NettyServerConfig nettyServerConfig;

    private final ConsumerOffsetManager consumerOffsetManager;
    private final ConsumerManager consumerManager;
    private final ProducerManager producerManager;
    private final Broker2Client broker2Client;
    private final ConsumerIdsChangeListener consumerIdsChangeListener;
    private final RebalanceLockManager rebalanceLockManager = new RebalanceLockManager();
    private final BrokerOuterAPI brokerOuterAPI;
    private MessageStore messageStore;
}
```

例如`offset`的管理就是基础配置(支持加载序列化为`json`文件等):

```java
public abstract class ConfigManager {
    public boolean load() {
        fileName = this.configFilePath();
        String jsonString = MixAll.file2String(fileName);
        this.decode(jsonString);
    }
   ...
}
public class ConsumerOffsetManager extends ConfigManager{
    ConcurrentMap<String/* topic@group */, ConcurrentMap<Integer, Long>> offsetTable =new..
    public long queryOffset(final String group, final String topic, final int queueId){...}
    public String encode(final boolean prettyFormat) {
        return RemotingSerializable.toJson(this, prettyFormat);
    }
}
```

`consumeManager`用户管理`consumer`, 当`consume`数量变化(新增减少超时), 通知其他`client`做`reblance`。

```java
public class ConsumerManager{
    private final ConcurrentMap<String/* Group */, ConsumerGroupInfo> consumerTable = new..;
    public void doChannelCloseEvent(String remoteAddr, Channel channel){
        // client 收到通知reblance
        this.consumerIdsChangeListener.handle(ConsumerGroupEvent.UNREGISTER, );
    }
    public boolean registerConsumer(String group){
        // client 收到通知reblance
        this.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group....);
    }
    public void unregisterConsumer(String group){
        // client 收到通知reblance
        this.consumerIdsChangeListener.handle(ConsumerGroupEvent.UNREGISTER, group);
    }
    public void scanNotActiveChannel() {  扫描client是否有超时
        auto itChannel = channelInfoTable.entrySet().iterator();
        while (itChannel.hasNext()) {
            if(timeout){
                RemotingUtil.closeChannel(clientChannelInfo.getChannel());
            }
        }
    }
}
```

`ProducerManager`管理`produce`逻辑类似(`produce`的信息可以提供给`mq admin`然后给管理后台提供接口获取`produce`信息)。

`/broker/processor`下主要是`broker`提供给`client`的`rpc`请求处理接口, `SendMessageProcessor`处理`produce`生产消息。


### 2. `RocketMQ` 如何实现顺序消息的生产



### 参考


