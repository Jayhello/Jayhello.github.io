---
layout: post
title: "RocketMQ原理-Consumer原理一"
date:   2022-08-13
tags: [RocketMQ]
comments: true
author: xy
# toc: true  # 这里加目录导致看到地方太小了
---

1. `RocketMQ` `Consumer`基本介绍, 以及简单示例

2. `RocketMQ` 如何实现顺序消息的生产

3. 生产者顺序消息需要注意的事项

### 1. `RocketMQ` `Consumer`基本介绍, 以及简单示例

`RocketMQ` 支持两种消息消费模式：`集群消费` 和`广播消费`。

`集群消费`：同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。

`广播消费`：当使用广播消费模式时，每条消息推送给集群内所有的消费者，保证消息至少被每个消费者消费一次。

两种模式如下图所示:

![img](../images/rocketmq.assests/consumer_1.png)

![img](../images/rocketmq.assests/consumer_2.png)


consume的简单示例如下(省略了异常处理这些):

```c++
void pullConsumeExample(){
  DefaultMQPullConsumer consumer("testGroup");
  consumer.setNamesrvAddr("127.0.0.1:9876");
  consumer.registerMessageQueueListener("testTopic", NULL);
  consumer.start();
  
  // 获取到topic的所有(broker-queue列表)
  std::vector<MQMessageQueue> mqs;
  consumer.fetchSubscribeMessageQueues("testTopic", mqs);
  auto iter = mqs.begin();
  for (; iter != mqs.end(); ++iter) {
    std::cout << "mq:" << (*iter).toString() << endl;
  }

  // 遍历所有的(broker-queue)
  for (auto iter = mqs.begin(); iter != mqs.end(); ++iter) {
    MQMessageQueue mq = (*iter);

    // 拉取订阅的消息
    PullResult result = consumer.pull(mq, "*", getMessageQueueOffset(mq), 32);
    if (result.pullStatus != BROKER_TIMEOUT) {
      putMessageQueueOffset(mq, result.nextBeginOffset);   // 更新消费位点
      PrintPullResult(&result);  // 打印消息
    } else {
      cout << "broker timeout occur" << endl;
    }
  }
}
```


### 2. `RocketMQ` 如何实现顺序消息的生产

分区(queue)顺序消息实现原理: 同类型的消息推送到同一个队列。例如下图:

   ![img](../images/rocketmq.assests/produce_1.png)


代码示例如下, 自定义队列`selector` 根据订单`id`取`hash`, 这样相同的订单`id`消息就推送到一个队列了:

```c++
class SelectMessageQueueByHash : public MessageQueueSelector {
  MQMessageQueue select(const std::vector<MQMessageQueue>& mqs, const MQMessage& msg, void* arg) {
    int orderId = *static_cast<int*>(arg);
    int index = orderId % mqs.size();
    return mqs[index];
  }
};
void produceOrder(){
  DefaultMQProducer producer("test_group");
  MQMessage msg("testOrder", "*", "orderid_123_pay");\
  string sOrderId = "20220709123556355";
  SelectMessageQueueByHash selector;
  SendResult sendResult = producer.send(msg, &selector, (void*)(&orderId), 3);
```

最后生产到队列类似如下图:

   ![img](../images/rocketmq.assests/produce_2.png)


全局顺序消息，那么只能使用一个队列，以及单个生产者，这是会严重影响性能, 一个队列示例如下:

   ![img](../images/rocketmq.assests/produce_2.png)


### 3. 生产者顺序消息需要注意的事项

如下几种情况可能导致生产消息无序:

1. 顺序消息必须使用1同步发送的方式才能保证生产者发送的消息有序(异步的话可能会出现先后到达的问题)

2. 如果某个broker挂了，那么队列就会减少一部分，如果采用取余的方式投递，将可能导致同一个业务中的不同消息被发送到不同的队列中，导致同一个业务的不同消息被存入不同的队列中，短暂的造成部分消息无序。

3. 如果增加了服务器broker(例如上面的hash值变了), 那么也会造成短暂的造成部分消息无序。

### 引用

保证顺序消费两个核心点，一个是生产者有序存储，另一个是消费者有序消费。消费者的顺序消费后面的文章在写。

https://juejin.cn/post/7149152825426542600

