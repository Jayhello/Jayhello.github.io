---
layout: post
title: "RocketMQ原理-Consumer原理一"
date:   2022-08-13
tags: [RocketMQ]
comments: true
author: xy
# toc: true  # 这里加目录导致看到地方太小了
---

1. `RocketMQ` `Consumer`基本介绍, 以及简单示例

2. `RocketMQ` `OffsetStore`的本地存储以及`broker`存储

3. 生产者顺序消息需要注意的事项

### 1. `RocketMQ` `Consumer`基本介绍, 以及简单示例

`RocketMQ` 支持两种消息消费模式：`集群消费` 和`广播消费`。

`集群消费`：同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。

`广播消费`：当使用广播消费模式时，每条消息推送给集群内所有的消费者，保证消息至少被每个消费者消费一次。

两种模式如下图所示:

![img](../images/rocketmq.assests/consumer_1.png)

![img](../images/rocketmq.assests/consumer_2.png)


consume的简单示例如下(省略了异常处理这些):

```c++
void pullConsumeExample(){
  DefaultMQPullConsumer consumer("testGroup");
  consumer.setNamesrvAddr("127.0.0.1:9876");
  consumer.registerMessageQueueListener("testTopic", NULL);
  consumer.start();
  
  // 获取到topic的所有(broker-queue列表)
  std::vector<MQMessageQueue> mqs;
  consumer.fetchSubscribeMessageQueues("testTopic", mqs);
  auto iter = mqs.begin();
  for (; iter != mqs.end(); ++iter) {
    std::cout << "mq:" << (*iter).toString() << endl;
  }

  // 遍历所有的(broker-queue)
  for (auto iter = mqs.begin(); iter != mqs.end(); ++iter) {
    MQMessageQueue mq = (*iter);

    // 拉取订阅的消息
    PullResult result = consumer.pull(mq, "*", getMessageQueueOffset(mq), 32);
    if (result.pullStatus != BROKER_TIMEOUT) {
      putMessageQueueOffset(mq, result.nextBeginOffset);   // 更新消费位点
      PrintPullResult(&result);  // 打印消息
    } else {
      cout << "broker timeout occur" << endl;
    }
  }
}
```


### 2. `RocketMQ` `OffsetStore`的本地存储以及`broker`存储

首先看下`OffsetStore`的使用, 启动`consumer`的时候:

1. 广播的时候用本地文件存储

2. 集群模式存储在broker端

```java
public class DefaultMQPullConsumerImpl{
....
private OffsetStore offsetStore;
public synchronized void start(){ // consumer启动的时候
...
    switch (this.defaultMQPullConsumer.getMessageModel()) {
        case BROADCASTING: //
            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory...);
            break;
        case CLUSTERING:    // 
            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory....);
    }
    this.offsetStore.load();
}
public long fetchConsumeOffset(MessageQueue mq, boolean fromStore) throws MQClientException {
    return this.offsetStore.readOffset(mq, ...);
}
public void updateConsumeOffsetToBroker(MessageQueue mq, offset...){
    this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);
}
public void updateConsumeOffset(MessageQueue mq, long offset){
    this.offsetStore.updateOffset(mq, offset, false);
```

与此同时支持`offset`的增删改查。下面看下`OffsetStore`的两种模式接口, 基类接口定义如下:

```java
public interface OffsetStore {
void load();
void updateOffset(final MessageQueue mq, final long offset);
long readOffset(final MessageQueue mq);
void persistAll(final Set<MessageQueue> mqs);
void persist(final MessageQueue mq);
void removeOffset(MessageQueue mq);
}
```

本地文件的存储定义如下(核心就是读取文件缓存以及更新文件)

```java
public class LocalFileOffsetStore implements OffsetStore {
    private final MQClientInstance mQClientFactory;
    private final String groupName;
    private final String storePath = LOCAL_DIR+File.separator+getClientId()+.."offsets.json";
    private ConcurrentMap<MessageQueue, AtomicLong> offsetTable = new ..; 缓存
    // 读取文件转化为mpa
    public void load(){
        // read from file 
        OffsetSerializeWrapper offsetSerializeWrapper = this.readLocalOffset();
        offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());
      ...
    }
}
```

数据格式是json, 例如:

```json
{"OffsetTable":{{" brokerName":" broker_a", "QueueId": 1," Topic":" broker1" }: 1,
{ "brokerName":" broker_b", "QueueId": 2," Topic":" broker1" }:2, 
{ "brokerName":" broker_c", "QueueId": 0, "Topic":" broker1" }:3 } }
```

远程的加载就是读取`broker`的`offset`, 更新也是存储到`broker`：

```java
public class RemoteBrokerOffsetStore implements OffsetStore {
private final MQClientInstance mQClientFactory;
private ConcurrentMap<MessageQueue, AtomicLong> offsetTable = new ...;

public long readOffset(final MessageQueue mq, final ReadOffsetType type){
   long brokerOffset = this.fetchConsumeOffsetFromBroker(mq);
   AtomicLong offset = new AtomicLong(brokerOffset);
   this.updateOffset(mq, offset.get(), false);
   return brokerOffset;   
}
private long fetchConsumeOffsetFromBroker(MessageQueue mq){
   FindBrokerResult findBrokerResult = mQClientFactory.findBrokerAddressInAdmin(getBrokerName());     
   QueryConsumerOffsetRequestHeader requestHeader = new QueryConsumerOffsetRequestHeader();
   requestHeader.setTopic(mq.getTopic());
   requestHeader.setConsumerGroup(this.groupName);
   requestHeader.setQueueId(mq.getQueueId());
   return mQClientFactory.getMQClientAPIImpl().queryConsumerOffset(getBrokerAddr(), requestHeader...);          
}
}
```

