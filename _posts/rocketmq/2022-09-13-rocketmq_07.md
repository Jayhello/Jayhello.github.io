---
layout: post
title: "RocketMQ原理-消费者Reblance"
date:   2022-09-13
tags: [RocketMQ]
comments: true
author: xy
# toc: true  # 这里加目录导致看到地方太小了
---

本文主要内容如下:



1. `RocketMQ` 消费者`Reblance`基本原理

2. 


### 1. `RocketMQ` 消费者`Reblance`基本原理

`Rebalance`(再均衡)机制指的是：将一个`Topic`下的多个队列(或称之为分区)，在同一个消费者组(`consumer group`)下的多个消费者实例(`consumer instance`)之间进行重新分配。 目的是为了提升消息的并行处理能力。

`RocketMQ`默认使用的是平均负载策略`AllocateMessageQueueAveragely`, 如果某个`Consumer`集群，订阅了某个`Topic`，`Topic`下面的这些`MessageQueue`会被平均分配给集群中的`Consumer`。例如下图:

![img](../images/rocketmq.assests/consumer_blance_1.png)

上面的图应该很好理解了, 需要注意的是, 当`MessageQueue`数量小于`Consumer`数量会有`Consumer`拿不到`Queue`。

例如上图`C5`排在最后面，队列全被别人拿走了，`C5`就一直分不到消息队列，除非前面的某个`Consumer`挂了，20s之后，在队列重新负载的时候就能拿到`MessageQueue`。

分配策略的接口定义如下:

```java
public interface AllocateMessageQueueStrategy{
    // 返回当前clientid被分配的 队列列表
    List<MessageQueue> allocate(
            String consumerGroup,
            String currentCID,              /*当前的client id*/
            List<MessageQueue> mqAll,       /*所有的队列*/
            List<String> cidAll             /*所有的clientid*/
    );
}
```

平均策略实现如下:

```java
public class AllocateMessageQueueAveragely implements AllocateMessageQueueStrategy {
@Override
List<MessageQueue> allocate(consumerGroup, currentCID, List<MessageQueue> mqAll,List<String> cidAll){
    List<MessageQueue> result = new ArrayList<MessageQueue>();
    int index = cidAll.indexOf(currentCID);
    int mod = mqAll.size() % cidAll.size();
    ...
    int range = Math.min(averageSize, mqAll.size() - startIndex);
    for (int i = 0; i < range; i++) {
        result.add(mqAll.get((startIndex + i) % mqAll.size()));
    }
    return result;
}
}
```

相同`group`下的所有`consumer client`都用用一种分配策略这样一般同一个队列在集群模式下就只会被一个`consumer`消费了。

还有其他策略, 例如 机房负载策略AllocateMessageQueueByMachineRoom当前Consumer只负载处在指定的机房内的MessageQueue。 AllocateMachineRoomNearby同机房的改进版本(这里简单带过下, 后面需要深入的时候再看)。



### 参考

https://blog.csdn.net/qq_38082304/article/details/112378245
